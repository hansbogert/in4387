sort 
     Bridge_Move = struct BridgeMoveUp | BridgeMoveDown | BridgeMoveStop;
     Bridge_Position = struct BridgeUp | BridgeDown;

     Barrier = struct B1|B2|B3|B4;
     Barrier_Position = struct BarrierUp | BarrierDown;
     Barrier_Move = struct BarrierMoveUp | BarrierMoveDown;
     Barriers = Barrier -> Barrier_Position;

     Lock = struct Locked | Unlocked; 
     Lock_Pin = struct L1 | L2;
     Lock_Pins = Lock_Pin -> Lock;
		
act proc_lock_pin_motor: Lock_Pin # Lock;
    user_lock_pin_motor: Lock_Pin # Lock;
    comm_lock_pin_motor: Lock_Pin # Lock;
    proc_lock_pins_change;
    comm_lock_pins_change;
    proc_lock_pins_unlocked;
    proc_lock_pins_locked;

    user_motor_action: Bridge_Move;
    proc_motor_action: Bridge_Move;
    comm_motor_action: Bridge_Move;
    proc_bridge_move;
    comm_bridge_move;

    proc_bridge_down, proc_bridge_up;    

    proc_barrier_down, proc_barrier_up;
    proc_barrier_move: Barrier # Barrier_Position;
    user_barrier_move: Barrier # Barrier_Position;
    comm_barrier_move: Barrier # Barrier_Position;
    proc_barrier_move_pins;
    comm_barrier_move_pins;

map initLockPins: Lock_Pin -> Lock;
    initBarriers: Barrier -> Barrier_Position;
var p: Lock_Pin;
    b: Barrier;
eqn initLockPins(p) = Locked;
    initBarriers(b) = BarrierUp;

proc
  LockPinMotors(motor: Lock_Pins) = 
      sum l: Lock_Pin, s: Lock . (motor(l) != s) -> proc_lock_pins_change . proc_lock_pin_motor(l, s) .
        LockPinMotors(motor[l->s])
      + !(exists l: Lock_Pin . motor(l) == Locked) -> proc_lock_pins_unlocked . LockPinMotors(motor)
      + !(exists l: Lock_Pin . motor(l) == Unlocked) -> proc_lock_pins_locked . LockPinMotors(motor);

  BarrierProcess(bars: Barriers) =
      sum b: Barrier, p:Barrier_Position . (bars(b) != p) -> proc_barrier_move_pins . proc_barrier_move(b, p) .  BarrierProcess(bars[b->p])
      + !(exists b: Barrier . bars(b) == BarrierUp) -> proc_barrier_down . BarrierProcess(bars)
      + !(exists b: Barrier . bars(b) == BarrierDown) -> proc_barrier_up . BarrierProcess(bars);
 
  Bridge(position: Bridge_Position) =
      %simpele versie van de Bridge
        (position == BridgeDown) -> proc_bridge_move . proc_motor_action(BridgeMoveUp) . proc_motor_action(BridgeMoveStop) .Bridge(BridgeUp)
      + (position == BridgeDown) -> proc_bridge_down . Bridge(BridgeDown)
      + (position == BridgeUp) -> proc_bridge_move . proc_motor_action(BridgeMoveDown) . proc_motor_action(BridgeMoveStop) . Bridge(BridgeDown)
      + (position == BridgeUp) -> proc_bridge_up . Bridge(BridgeUp);

  User = 
        %de gebruiker kan altijd alle knoppen indrukken
        sum l: Lock_Pin, s: Lock . user_lock_pin_motor(l, s) . User
      + sum m: Bridge_Move . user_motor_action(m) . User
      + sum b: Barrier, p: Barrier_Position . user_barrier_move(b, p) . User;

init
  allow(
    { comm_lock_pins_change, comm_lock_pin_motor, comm_bridge_move, comm_motor_action, comm_barrier_move_pins, comm_barrier_move },
    comm(
      { %the lockpinnen mogen veranderen als de Barriers naar beneden staan en de Brug omlaag staat
        proc_lock_pins_change|proc_barrier_down|proc_bridge_down -> comm_lock_pins_change,
        %zodra de User en de LockPins een LockPin actie goedkeuren kan deze gebeuren
        user_lock_pin_motor|proc_lock_pin_motor -> comm_lock_pin_motor,
        %de Brug mag dus alleen bewegen als de Lockpinnen unlocked zijn.
        proc_bridge_move|proc_lock_pins_unlocked -> comm_bridge_move,
        %zodra de User en de Brug een motor actie goedkeuren dan gebeurt deze
        user_motor_action|proc_motor_action -> comm_motor_action,
        %de Barrier mogen pas omhoog zodra de Pinnen gelockt zijn
        proc_barrier_move_pins|proc_lock_pins_locked -> comm_barrier_move_pins,
        %zodra de user en de Barrier de actie (Barrier een nieuw status geven) goedkeuren dan kan deze actie gebeuren
        user_barrier_move|proc_barrier_move -> comm_barrier_move }
      , LockPinMotors(initLockPins) || Bridge(BridgeDown) || BarrierProcess(initBarriers) || User
  ) ) ;
